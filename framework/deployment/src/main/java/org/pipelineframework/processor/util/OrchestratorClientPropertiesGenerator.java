package org.pipelineframework.processor.util;

import java.io.IOException;
import java.io.InputStream;
import java.io.StringWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import javax.annotation.processing.ProcessingEnvironment;
import javax.tools.StandardLocation;

import org.pipelineframework.config.pipeline.PipelineYamlConfig;
import org.pipelineframework.config.pipeline.PipelineYamlConfigLoader;
import org.pipelineframework.config.pipeline.PipelineYamlConfigLocator;
import org.pipelineframework.config.pipeline.PipelineYamlStep;
import org.pipelineframework.processor.PipelineCompilationContext;
import org.pipelineframework.processor.ir.GenerationTarget;
import org.pipelineframework.processor.ir.PipelineStepModel;

/**
 * Generates orchestrator client configuration properties based on the compiled pipeline model.
 */
public class OrchestratorClientPropertiesGenerator {

    private static final String RESOURCE_PATH = "META-INF/pipeline/orchestrator-clients.properties";

    private final ProcessingEnvironment processingEnv;

    /**
     * Creates a new OrchestratorClientPropertiesGenerator.
     *
     * @param processingEnv the processing environment for compiler utilities and messaging
     */
    public OrchestratorClientPropertiesGenerator(ProcessingEnvironment processingEnv) {
        this.processingEnv = processingEnv;
    }

    /**
     * Writes the orchestrator client configuration to META-INF/pipeline/orchestrator-clients.properties.
     *
     * @param ctx the compilation context
     * @throws IOException if writing the resource fails
     */
    public void writeClientProperties(PipelineCompilationContext ctx) throws IOException {
        if (!ctx.isOrchestratorGenerated()) {
            return;
        }

        List<PipelineStepModel> models = ctx.getStepModels();
        if (models == null || models.isEmpty()) {
            return;
        }

        List<PipelineStepModel> clientModels = filterClientModels(models, ctx.isTransportModeGrpc());
        if (clientModels.isEmpty()) {
            return;
        }

        OrchestratorClientModuleMapping mapping = loadModuleMapping(ctx);
        List<PipelineStepModel> orderedBaseSteps = orderBaseSteps(ctx, clientModels);
        List<PipelineStepModel> sideEffects = clientModels.stream()
            .filter(PipelineStepModel::sideEffect)
            .toList();

        List<String> moduleOrder = resolveModuleOrder(orderedBaseSteps, sideEffects, mapping);
        mapping = mapping.withResolvedModules(moduleOrder);

        StringWriter writer = new StringWriter();
        writer.append("# Generated by pipeline annotation processing. Overrides can be provided in application.properties.\n");

        if (ctx.isTransportModeGrpc()) {
            renderGrpcClients(writer, orderedBaseSteps, sideEffects, mapping);
        } else {
            renderRestClients(writer, orderedBaseSteps, sideEffects, mapping);
        }

        javax.tools.FileObject resourceFile = processingEnv.getFiler()
            .createResource(StandardLocation.CLASS_OUTPUT, "", RESOURCE_PATH, (javax.lang.model.element.Element[]) null);
        try (var output = resourceFile.openWriter()) {
            output.write(writer.toString());
        }
    }

    private List<PipelineStepModel> filterClientModels(List<PipelineStepModel> models, boolean grpcTransport) {
        GenerationTarget target = grpcTransport ? GenerationTarget.CLIENT_STEP : GenerationTarget.REST_CLIENT_STEP;
        return models.stream()
            .filter(model -> model.enabledTargets().contains(target))
            .toList();
    }

    private OrchestratorClientModuleMapping loadModuleMapping(PipelineCompilationContext ctx) {
        Properties properties = new Properties();
        try {
            properties = loadApplicationProperties(ctx);
        } catch (IOException e) {
            processingEnv.getMessager().printMessage(javax.tools.Diagnostic.Kind.WARNING,
                "Failed to read application.properties for module mapping overrides: " + e.getMessage());
        }
        return OrchestratorClientModuleMapping.fromProperties(properties, processingEnv);
    }

    private Properties loadApplicationProperties(PipelineCompilationContext ctx) throws IOException {
        Properties properties = new Properties();
        for (Path baseDir : getBaseDirectories(ctx)) {
            Path propertiesPath = baseDir.resolve("src/main/resources/application.properties");
            if (Files.exists(propertiesPath) && Files.isReadable(propertiesPath)) {
                try (InputStream input = Files.newInputStream(propertiesPath)) {
                    properties.load(input);
                    return properties;
                }
            }
        }

        try {
            var resource = processingEnv.getFiler()
                .getResource(StandardLocation.SOURCE_PATH, "", "application.properties");
            try (InputStream input = resource.openInputStream()) {
                properties.load(input);
            }
        } catch (Exception e) {
            // Ignore when the resource is not available.
        }

        return properties;
    }

    private Set<Path> getBaseDirectories(PipelineCompilationContext ctx) {
        Set<Path> baseDirs = new LinkedHashSet<>();
        if (ctx != null && ctx.getModuleDir() != null) {
            baseDirs.add(ctx.getModuleDir());
        }
        String multiModuleDir = System.getProperty("maven.multiModuleProjectDirectory");
        if (multiModuleDir != null && !multiModuleDir.isBlank()) {
            baseDirs.add(Paths.get(multiModuleDir));
        }
        baseDirs.add(Paths.get(System.getProperty("user.dir", ".")));
        return baseDirs;
    }

    private List<PipelineStepModel> orderBaseSteps(
        PipelineCompilationContext ctx,
        List<PipelineStepModel> models
    ) {
        List<PipelineStepModel> baseSteps = models.stream()
            .filter(model -> !model.sideEffect())
            .toList();
        PipelineYamlConfig config = loadPipelineConfig(ctx);
        if (config == null || config.steps() == null || config.steps().isEmpty()) {
            return baseSteps;
        }

        List<PipelineStepModel> remaining = new ArrayList<>(baseSteps);
        List<PipelineStepModel> ordered = new ArrayList<>();
        for (PipelineYamlStep step : config.steps()) {
            if (step == null || step.name() == null) {
                continue;
            }
            String token = toClassToken(step.name());
            if (token.isBlank()) {
                continue;
            }
            PipelineStepModel match = selectBestMatch(remaining, token);
            if (match != null) {
                ordered.add(match);
                remaining.remove(match);
            }
        }
        ordered.addAll(remaining);
        return ordered;
    }

    private PipelineYamlConfig loadPipelineConfig(PipelineCompilationContext ctx) {
        PipelineYamlConfigLocator locator = new PipelineYamlConfigLocator();
        Path moduleDir = ctx.getModuleDir();
        if (moduleDir == null) {
            return null;
        }
        java.util.Optional<Path> configPath = locator.locate(moduleDir);
        if (configPath.isEmpty()) {
            return null;
        }
        PipelineYamlConfigLoader loader = new PipelineYamlConfigLoader();
        return loader.load(configPath.get());
    }

    private PipelineStepModel selectBestMatch(List<PipelineStepModel> candidates, String token) {
        PipelineStepModel best = null;
        int bestLength = -1;
        for (PipelineStepModel candidate : candidates) {
            if (candidate == null) {
                continue;
            }
            String normalized = normalizeStepToken(candidate.serviceName());
            if (normalized.contains(token) && token.length() > bestLength) {
                best = candidate;
                bestLength = token.length();
            }
        }
        return best;
    }

    private String normalizeStepToken(String className) {
        String simple = className == null ? "" : className;
        int lastDot = simple.lastIndexOf('.');
        if (lastDot != -1) {
            simple = simple.substring(lastDot + 1);
        }
        simple = simple.replaceAll("(Service|GrpcClientStep|RestClientStep)(_Subclass)?$", "");
        return toClassToken(simple);
    }

    private String toClassToken(String name) {
        if (name == null) {
            return "";
        }
        return name.replaceAll("[^A-Za-z0-9]", "");
    }

    private List<String> resolveModuleOrder(
        List<PipelineStepModel> baseSteps,
        List<PipelineStepModel> sideEffects,
        OrchestratorClientModuleMapping mapping
    ) {
        List<String> ordered = new ArrayList<>();
        for (PipelineStepModel model : baseSteps) {
            String moduleName = mapping.resolveModuleName(model);
            addModuleIfAbsent(ordered, moduleName);
        }
        for (PipelineStepModel model : sideEffects) {
            String moduleName = mapping.resolveModuleName(model);
            addModuleIfAbsent(ordered, moduleName);
        }
        return ordered;
    }

    private void addModuleIfAbsent(List<String> modules, String moduleName) {
        if (moduleName == null || moduleName.isBlank()) {
            return;
        }
        if (!modules.contains(moduleName)) {
            modules.add(moduleName);
        }
    }

    private void renderGrpcClients(
        StringWriter writer,
        List<PipelineStepModel> baseSteps,
        List<PipelineStepModel> sideEffects,
        OrchestratorClientModuleMapping mapping
    ) {
        List<PipelineStepModel> all = new ArrayList<>();
        all.addAll(baseSteps);
        all.addAll(sideEffects);

        for (PipelineStepModel model : all) {
            OrchestratorClientModuleMapping.ClientConfig client = mapping.clientConfig(model);
            if (client == null) {
                continue;
            }
            writer.append("\n# Talk to ").append(client.name()).append(" service\n");
            writer.append("quarkus.grpc.clients.").append(client.name()).append(".host=")
                .append(client.host()).append("\n");
            writer.append("quarkus.grpc.clients.").append(client.name()).append(".port=")
                .append(String.valueOf(client.port())).append("\n");
            writer.append("quarkus.grpc.clients.").append(client.name())
                .append(".use-quarkus-grpc-client=true\n");
            if (client.tlsConfigurationName() != null) {
                String tlsDefault = client.tlsConfigurationName();
                String tlsExpression = "${pipeline.client.tls-configuration-name:" + tlsDefault + "}";
                writer.append("quarkus.grpc.clients.").append(client.name())
                    .append(".tls-configuration-name=")
                    .append(tlsExpression).append("\n");
                writer.append("quarkus.grpc.clients.").append(client.name())
                    .append(".tls.enabled=true\n");
                writer.append("quarkus.grpc.clients.").append(client.name())
                    .append(".plain-text=false\n");
            }
        }
    }

    private void renderRestClients(
        StringWriter writer,
        List<PipelineStepModel> baseSteps,
        List<PipelineStepModel> sideEffects,
        OrchestratorClientModuleMapping mapping
    ) {
        List<PipelineStepModel> all = new ArrayList<>();
        all.addAll(baseSteps);
        all.addAll(sideEffects);

        for (PipelineStepModel model : all) {
            OrchestratorClientModuleMapping.ClientConfig client = mapping.clientConfig(model);
            if (client == null) {
                continue;
            }
            writer.append("\n# Talk to ").append(client.name()).append(" service\n");
            writer.append("quarkus.rest-client.").append(client.name()).append(".url=https://")
                .append(client.host()).append(":").append(String.valueOf(client.port())).append("\n");
            if (client.tlsConfigurationName() != null) {
                String tlsDefault = client.tlsConfigurationName();
                String tlsExpression = "${pipeline.client.tls-configuration-name:" + tlsDefault + "}";
                writer.append("quarkus.rest-client.").append(client.name())
                    .append(".tls-configuration-name=")
                    .append(tlsExpression).append("\n");
            }
        }
    }
}
