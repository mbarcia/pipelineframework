package {{basePackage}}.{{serviceNameForPackage}}.service;

import {{basePackage}}.common.domain.{{inputTypeName}};
import {{basePackage}}.common.domain.{{outputTypeName}};
import org.pipelineframework.grpc.{{grpcAdapter}};
import org.pipelineframework.annotation.PipelineStep;
import org.pipelineframework.service.{{reactiveServiceInterface}};
import org.pipelineframework.step.{{stepType}};
import io.smallrye.mutiny.Uni;
import io.smallrye.mutiny.Multi;
import jakarta.enterprise.context.ApplicationScoped;
import lombok.Getter;
import org.jboss.logging.Logger;

@PipelineStep(
    inputType = {{basePackage}}.common.domain.{{inputTypeName}}.class,
    outputType = {{basePackage}}.common.domain.{{outputTypeName}}.class,
    stepType = org.pipelineframework.step.{{stepType}}.class,
    backendType = org.pipelineframework.grpc.{{grpcAdapter}}.class,
    inboundMapper = {{basePackage}}.common.mapper.{{inputTypeName}}Mapper.class,
    outboundMapper = {{basePackage}}.common.mapper.{{outputTypeName}}Mapper.class,
    runOnVirtualThreads = false
)
@ApplicationScoped
@Getter
public class Process{{serviceNamePascal}}Service
    implements {{reactiveServiceInterface}}<{{inputTypeName}}, {{outputTypeName}}> {

  @Override
  public {{{processMethodReturnType}}} process({{{processMethodParamType}}} input) {
    Logger logger = Logger.getLogger(getClass());

    // TODO implement business logic here
    logger.infof("Processing input: %s", input);
    
    {{outputTypeName}} output = new {{outputTypeName}}();
    // Set output fields based on input
    // TODO: Add actual business logic here
    
    return {{{returnStatement}}};
  }
}
